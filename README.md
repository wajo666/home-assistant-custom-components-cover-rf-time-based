# Cover Time Based script/entity

[![hacs_badge](https://img.shields.io/badge/HACS-Default-orange.svg?style=for-the-badge)](https://github.com/hacs/integration)
[![GitHub release](https://img.shields.io/github/release/wajo666/home-assistant-custom-components-cover-rf-time-based.svg?style=for-the-badge)](https://github.com/wajo666/home-assistant-custom-components-cover-rf-time-based/releases)
[![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-green.svg?style=for-the-badge)](https://github.com/wajo666/home-assistant-custom-components-cover-rf-time-based/graphs/commit-activity)

> **üéâ Version 2.2.4 Released!** - Comprehensive fix for optional field validation! All optional entity selectors and templates now work correctly when left empty in both script and wrapper modes. No more "Entity None" errors!

Cover Time Based Component for your [Home-Assistant](http://www.home-assistant.io) based on [davidramosweb's Cover Time Based Component](https://github.com/davidramosweb/home-assistant-custom-components-cover-time-based), modified for native cover entities, covers triggered by RF commands, or any other unidirectional methods.

**Note**: _Since ESPHome v1.15.0 (September 13, 2020) it is possible to implement a Time Based Cover entirely in the Sonoff RF Bridge hardware, which excludes the necessity of this component (at least of the RF part). Jump to the bottom of this readme for an example how to set it up._

With this component you can add a time-based cover with optional TILT support. You either have to set triggering scripts to open, close and stop the cover or you can use an existing cover entity provided by another integration which does not have timing or status feedback. Position (and tilt position if configured) is calculated based on the fraction of time spent by the cover travelling up or down. You can set position from within Home Assistant using service calls. When you use this component, you can forget about the cover's original remote controllers or switches, because there's no feedback from the cover about its real state, state is assumed based on the last command sent from Home Assistant. There's also a custom service available where you can update the real state of the cover based on external sensors if you want to.

You can adapt it to your requirements, actually any cover system could be used which uses 3 triggers: up, stop, down (and optionally separate tilt controls). The idea is to embed your triggers into scripts which can be hooked into this component via config. For example, you can use RF-bridge or dual-gang switch running Tasmota or ESPHome firmware integrated like in the examples shown below.

When you use it to extend functionality of an existing cover implementation, this component will generate a new cover entity with these new features.

The component adds two services ```set_known_position``` and ```set_known_action``` which allow updating HA in response to external stimuli like sensors. The ```set_known_position``` service supports both main position and tilt position updates. 

The entities generated by this component have assumed states, which are remembered between Home Assistant restarts.

[Support forum](https://community.home-assistant.io/t/custom-component-cover-time-based/187654/3?u=robi)

## What's New in v2.0

Version 2.0 brings a major architectural improvement:

### üèóÔ∏è Modular Architecture
The monolithic 677-line `cover.py` has been split into focused, maintainable modules:
- **`cover.py`** (57 lines) - Thin orchestrator for platform setup
- **`const.py`** - Centralized constants and defaults
- **`models.py`** - Type-safe dataclasses (DeviceConfig, ScriptsConfig, WrapperConfig)
- **`helpers.py`** - YAML schemas, factory functions, and duplicate guard
- **`entity.py`** - Complete CoverTimeBased entity implementation

### üõ°Ô∏è Duplicate Entity Protection
Built-in guard prevents duplicate entity creation during:
- Integration reloads
- Home Assistant upgrades
- YAML configuration reloads

### üìä Code Quality Improvements
- **-91.6%** main file size reduction (677 ‚Üí 57 lines)
- **-78.9%** fewer `__init__` parameters (19 ‚Üí 4 via dataclasses)
- **100%** type hints coverage
- **Enhanced** separation of concerns

### ‚úÖ Backward Compatibility
**No configuration changes required!** All existing YAML configurations work identically.


## Installation

[![hacs_badge](https://img.shields.io/badge/HACS-Default-orange.svg?style=for-the-badge)](https://github.com/hacs/integration)

### Option 1: HACS (Recommended)

This integration is available in the default HACS repository.

1. **Install HACS** (if not already installed)
   - Follow the [HACS installation guide](https://hacs.xyz/docs/setup/download)

2. **Add the integration via HACS**
   - Open Home Assistant
   - Go to **HACS** ‚Üí **Integrations**
   - Click **+ EXPLORE & DOWNLOAD REPOSITORIES**
   - Search for **"Cover Time Based"** or **"Cover RF Time Based"**
   - Click on the integration
   - Click **DOWNLOAD**
   - Select the latest version
   - Click **DOWNLOAD** again

3. **Restart Home Assistant**
   - Go to **Settings** ‚Üí **System** ‚Üí **Restart**
   - Or use the command: `homeassistant.restart`

4. **Configure the integration**
   - See [Configuration](#configuration) section below

**Benefits of HACS installation:**
- ‚úÖ Easy updates - get notified of new versions
- ‚úÖ One-click update process
- ‚úÖ Automatic dependency management
- ‚úÖ Integration shows up in HACS integrations list

### Option 2: Manual Installation

For advanced users who don't use HACS:

1. **Download the latest release** from [GitHub Releases](https://github.com/wajo666/home-assistant-custom-components-cover-rf-time-based/releases)

2. **Copy files to Home Assistant**
   - Extract and copy the `custom_components/cover_rf_time_based` folder to your `<config>/custom_components/` directory
   - Full path: `<config>/custom_components/cover_rf_time_based/`

3. **Restart Home Assistant**

4. **Add integration via UI** (see step 4 in HACS method above)

## Configuration

You can configure this integration in **two ways**:

### Option A: UI Configuration (Recommended ‚≠ê)

The easiest way to set up covers - no YAML editing required!

1. Go to **Settings** ‚Üí **Devices & Services**
2. Click **+ ADD INTEGRATION**
3. Search for **"Cover Time Based"**
4. Choose your mode:
   - **Script-based**: Use custom scripts (RF, MQTT, relays, etc.)
   - **Wrapper**: Extend an existing cover entity
5. Fill in the configuration form
6. Click **Submit**

**Note:** If you have YAML configurations, the integration will **automatically appear** in "Devices & Services" with a "YAML Configuration" entry. You don't need to manually add it first!

**Configuration Options:**
- **Name**: Entity name (e.g., "Bedroom Blinds")
- **Device Class**: Type of cover (shutter, blind, curtain, etc.)
- **Travel Times**: How long it takes to fully open/close (seconds)
- **Tilt Times**: How long it takes to fully tilt (if applicable)
- **Command Delay**: Delay between command and motor start (accounts for RF/motor delays)
- **Scripts**: Scripts for open/close/stop (and optionally tilt)
- **Availability Template**: Template to control when cover is available (optional)
- **Options**: Send stop at ends, always confident, tilt restrictions

**Hybrid Mode Example:**
Want to add tilt to a cover that doesn't support it?
1. Choose **Wrapper** mode
2. Select your existing cover (e.g., `cover.zigbee_blinds`)
3. Add **Tilt Scripts** for custom tilt control
4. Result: Main movement from Zigbee, tilt from your RF scripts!

**üÜï Automatic State Synchronization (v2.2.1):**
In hybrid/wrapper mode, the cover automatically syncs with the wrapped cover:
- ‚úÖ Control via physical switches ‚Üí hybrid cover updates automatically
- ‚úÖ Control via automations ‚Üí position stays synchronized
- ‚úÖ External state changes ‚Üí reflected in real-time
- ‚úÖ No configuration needed ‚Üí works out of the box!

**üîÑ Migrating from YAML?**
- ‚úÖ Automatic mode detection (wrapper vs script-based)
- ‚úÖ One-click migration preserves all settings
- ‚úÖ No manual configuration needed
- See [MIGRATION.md](MIGRATION.md) for step-by-step guide.

See [MIGRATION.md](MIGRATION.md) for detailed UI configuration guide.

### Option B: YAML Configuration (Legacy)

You can also configure covers via YAML. Both YAML and UI configurations can coexist!

#### Basic Script-Based Configuration
   - See [Configuration](#configuration) section below

**Manual installation structure:**
```
<config directory>/
‚îú‚îÄ‚îÄ configuration.yaml
‚îî‚îÄ‚îÄ custom_components/
    ‚îî‚îÄ‚îÄ cover_rf_time_based/
        ‚îú‚îÄ‚îÄ __init__.py
        ‚îú‚îÄ‚îÄ config_flow.py
        ‚îú‚îÄ‚îÄ const.py
        ‚îú‚îÄ‚îÄ cover.py
        ‚îú‚îÄ‚îÄ entity.py
        ‚îú‚îÄ‚îÄ helpers.py
        ‚îú‚îÄ‚îÄ manifest.json
        ‚îú‚îÄ‚îÄ models.py
        ‚îú‚îÄ‚îÄ services.yaml
        ‚îú‚îÄ‚îÄ strings.json
        ‚îú‚îÄ‚îÄ travelcalculator.py
        ‚îî‚îÄ‚îÄ translations/
            ‚îú‚îÄ‚îÄ en.json
            ‚îî‚îÄ‚îÄ sk.json
```

## Configuration

### UI Configuration (Recommended)

The easiest way to set up covers is through the Home Assistant UI:

1. Go to **Settings** ‚Üí **Devices & Services**
2. Click **+ ADD INTEGRATION**
3. Search for **"Cover Time Based"**
4. Choose your configuration mode:
   - **Script-based (recommended)**: Control covers using scripts
   - **Wrapper**: Enhance an existing cover entity with position/tilt tracking
   - **Hybrid**: Combine wrapper cover (for main movement) with tilt scripts (for tilt control)
5. Fill in the configuration form:
   - Basic settings: name, device class, travel times
   - Scripts or wrapper entity
   - Optional: tilt settings, command delay, availability template
6. Click **Submit**

**Benefits of UI Configuration:**
- ‚úÖ No YAML editing required
- ‚úÖ Template editor with autocomplete for availability templates
- ‚úÖ Live configuration updates (no restart needed)
- ‚úÖ Immediate validation feedback
- ‚úÖ Entity picker for easy script/entity selection
- ‚úÖ Easy to modify later via Options flow

**Available Fields:**
- **Name**: Cover entity name
- **Device Class**: Type of cover (shutter, blind, curtain, etc.)
- **Travel Times**: Time to fully open/close (in seconds)
- **Tilt Times**: Time to fully tilt slats (optional)
- **Command Delay**: RF/motor startup delay (optional)
- **Scripts**: Entity IDs for open/close/stop/tilt operations
- **Wrapper Entity**: Existing cover entity to enhance (wrapper mode)
- **Availability Template**: Jinja2 template to control availability (optional)
- **Behavioral Options**: Send stop at ends, always confident, tilt restrictions

**To modify settings later:**
1. Go to **Settings** ‚Üí **Devices & Services**
2. Find the **Cover Time Based (script/entity)** integration
3. Click **CONFIGURE**
4. Update settings and click **Submit**
5. Changes apply immediately without restart!

### Hybrid Mode: Wrapper + Tilt Scripts

**New in v2.1!** You can now combine wrapper mode with tilt scripts for maximum flexibility:

**Use Case:** You have an existing cover entity that handles open/close/stop, but you want to add custom tilt functionality.

**How it works:**
- **Main movement** (open, close, stop, position) ‚Üí Uses the wrapper cover entity
- **Tilt control** (tilt open, tilt close, tilt stop, tilt position) ‚Üí Uses your custom scripts
- **Stop fallback** (v2.2.1) ‚Üí If wrapper doesn't support stop, uses `stop_script_entity_id` as fallback

**Configuration Steps:**
1. Select **"Wrapper (existing cover entity)"** mode
2. Set **Cover Entity** to your existing cover (e.g., `cover.bedroom_blinds`)
3. Add your **Tilt Scripts**:
   - **Tilt Open Script**: `script.bedroom_tilt_open`
   - **Tilt Close Script**: `script.bedroom_tilt_close`
   - **Tilt Stop Script**: `script.bedroom_tilt_stop` (optional)
4. Configure **Tilt Times** (e.g., 1.5 seconds)
5. (Optional) Add **Stop Script** if wrapper doesn't support stop command

**Example Scenario:**
```
Existing: cover.bedroom_blinds (no tilt support)
Goal: Add RF-based tilt control

Solution:
- Wrapper Entity: cover.bedroom_blinds
- Tilt Scripts: Custom RF scripts for tilt
- Stop Script: script.bedroom_stop (if wrapper lacks stop support)
- Result: Main movement uses existing cover, tilt uses RF scripts
```

**Benefits:**
- ‚úÖ Keep using your existing cover integration
- ‚úÖ Add tilt functionality without modifying original integration
- ‚úÖ Use different control methods (e.g., Zigbee for main, RF for tilt)
- ‚úÖ Separate timing for main movement vs tilt
- ‚úÖ Automatic fallback to stop script if wrapper doesn't support stop
- ‚úÖ Best of both worlds!

### YAML Configuration (Legacy)

You can also configure covers via YAML. See [Migration Guide](MIGRATION.md) for switching from YAML to UI.

### Usage
To use this component in your installation, you have to either set RF-sending scripts to open, close and stop the cover (see below), or use an existing cover entity provided by another integration, which is missing the features provided here.

### Example configuration.yaml entry
Add the following to your configuration.yaml file:
  
```yaml
cover:
  - platform: cover_rf_time_based
    devices:
      my_room_cover_time_based:
        name: My Room Cover
        travelling_time_up: 36
        travelling_time_down: 34
        close_script_entity_id: script.rf_myroom_cover_down
        stop_script_entity_id: script.rf_myroom_cover_stop
        open_script_entity_id: script.rf_myroom_cover_up
        send_stop_at_ends: False #optional
        command_delay: 0 #optional (time in seconds, can be float like 0.5)
        always_confident: False #optional
        device_class: garage #optional
        availability_template: "{{ is_state('binary_sensor.rf_bridge_status', 'on') }}" #optional
```

#### Configuration with TILT support:
```yaml
cover:
  - platform: cover_rf_time_based
    devices:
      my_room_blinds:
        name: My Room Blinds
        travelling_time_up: 36
        travelling_time_down: 34
        tilting_time_up: 1.5 #optional
        tilting_time_down: 1.5 #optional
        close_script_entity_id: script.rf_myroom_cover_down
        stop_script_entity_id: script.rf_myroom_cover_stop
        open_script_entity_id: script.rf_myroom_cover_up
        tilt_open_script_entity_id: script.rf_myroom_tilt_up #optional
        tilt_close_script_entity_id: script.rf_myroom_tilt_down #optional
        tilt_stop_script_entity_id: script.rf_myroom_tilt_stop #optional
        tilt_only_when_closed: False #optional (defaults to False)
```
  
**OR** using existing cover entity (wrapper mode):  
  
```yaml
cover:
  - platform: cover_rf_time_based
    devices:
      my_room_cover_time_based:
        name: My Room Cover
        travelling_time_up: 36
        travelling_time_down: 34
        cover_entity_id: cover.myroom
        send_stop_at_ends: True #optional
        always_confident: True #optional
        device_class: curtain #optional
        availability_template: "{{ not (is_state('cover.myroom', 'unavailable') or is_state('cover.myroom', 'unknown')) }}" #optional
```

#### Hybrid Mode: Wrapper with Tilt Scripts (NEW in v2.1+)

**Perfect for adding tilt to covers that don't support it!**

Combine an existing cover entity for main movement with custom tilt scripts:

```yaml
cover:
  - platform: cover_rf_time_based
    devices:
      living_room_blinds_hybrid:
        name: Living Room Blinds
        travelling_time_up: 28
        travelling_time_down: 29
        cover_entity_id: cover.zigbee_blinds  # Main movement from Zigbee cover
        tilting_time_up: 5
        tilting_time_down: 10
        tilt_open_script_entity_id: script.rf_tilt_open  # Tilt from RF scripts
        tilt_close_script_entity_id: script.rf_tilt_close
        command_delay: 0
        send_stop_at_ends: False
        availability_template: "{{ not (is_state('cover.zigbee_blinds', 'unavailable') or is_state('cover.zigbee_blinds', 'unknown')) }}"
```

**How Hybrid Mode Works:**
- **Main cover commands** (open, close, stop, set_position) ‚Üí forwarded to `cover_entity_id`
- **Tilt commands** (tilt_open, tilt_close, tilt_stop, set_tilt_position) ‚Üí use your custom scripts
- **Stop fallback** (v2.2.2+) ‚Üí if wrapper doesn't support stop, uses `stop_script_entity_id`
- **State sync** (v2.2.1+) ‚Üí automatically syncs with wrapped cover when controlled externally
- **Command delay** ‚Üí applies to BOTH wrapper commands AND tilt scripts (use slower system's delay)

**Real-World Example:**
You have a Zigbee blind with open/close but no tilt. You want to add RF-based tilt control:
- Zigbee handles: opening, closing, positioning (fast, no delay needed)
- RF handles: tilting slats (slower, may need 0.3-0.5s delay)
- `command_delay: 0.5` ‚Üí applies to both Zigbee AND RF commands
- Result: Best of both worlds with precise positioning!

#### Configuration with TILT support using existing cover entity:
```yaml
cover:
  - platform: cover_rf_time_based
    devices:
      my_room_blinds_time_based:
        name: My Room Blinds
        travelling_time_up: 36
        travelling_time_down: 34
        tilting_time_up: 1.5 #optional
        tilting_time_down: 1.5 #optional
        cover_entity_id: cover.myroom_blinds
        tilt_only_when_closed: False #optional (defaults to False)
```

**Note**: When using `cover_entity_id`, all cover commands (including tilt commands if configured) are forwarded to the specified cover entity. The time-based component adds position tracking and tilt position tracking capabilities on top of the existing cover entity. This is useful when you have a cover integration that doesn't provide position feedback or tilt control, and you want to add these features.

All mandatory settings self-explanatory. 

Optional settings:
- `send_stop_at_ends` defaults to `False`. If set to `True`, the Stop script will be run after the cover reaches to 0 or 100 (closes or opens completely). This is for people who use interlocked relays in the scripts to drive the covers, which need to be released when the covers reach the end positions.
- `command_delay` defaults to `0` (seconds). Specifies the delay between sending a command and the actual execution. This accounts for RF signal transmission delays, motor startup time, or any other delays in your system. **Important**: This delay applies to **both START and STOP commands** in **ALL modes** (script-based, wrapper, and hybrid). For example, if set to `0.5`:
  - OPEN command sent at t=0s ‚Üí Motor starts at t=0.5s
  - For 30% position (3s travel): STOP sent at t=3.0s ‚Üí Motor stops at t=3.5s (exactly at 30%)
  - This ensures the motor stops precisely at the target position without overshooting.
  - **Wrapper/Hybrid mode**: Delay applies to wrapper cover commands AND tilt script commands
  - **Recommendation**: Set to `0` for fast systems (Zigbee/Z-Wave), `0.3-0.5` for RF systems
- `always_confident` defaults to `False`. **Controls whether Home Assistant treats the cover position as reliable or estimated.**
  - **`False` (default, recommended)**: Cover has `assumed_state = True`
    - UI knows the position is an **estimate** (calculated from time)
    - All buttons (Open/Close/Stop) are **always active**
    - Cover can be controlled even if position is uncertain
    - **‚úÖ Use for RF covers** (no feedback from motor)
    - **‚úÖ Use if external remotes** can change position outside HA
    - **‚úÖ Recommended for 90% of use cases**
  - **`True` (use with caution)**: Cover has `assumed_state = False`
    - UI treats the position as **accurate and reliable**
    - Buttons **deactivate** based on state (e.g., Open button disabled when fully opened)
    - **‚ö†Ô∏è Can cause issues** if cover is moved by external controls
    - **‚ö†Ô∏è Not recommended for RF covers** (no real position feedback)
    - **‚ö†Ô∏è Only use if:**
      - You control the cover EXCLUSIVELY through Home Assistant
      - You NEVER use physical buttons or original remotes
      - You set correct position with `set_known_position` after HA restarts
  - **Example problem with `True`**: If cover is at 100% in HA but someone closes it manually, the Open button becomes disabled and you can't open it via UI until you fix the state with `set_known_position` service.
- `device_class` defaults to `shutter` if not specified. See the docs for availale [cover device classes](http://dev-docs.home-assistant.io/en/master/api/components.html#homeassistant.components.cover.CoverDeviceClass).
- `availability_template` if not specified will make the cover always available. You can use a template returning `True` or `False` in order to toggle availability of the cover based on other entities. Useful to link with the connection status of your RF Bridge or relays device. **Now fully supported in UI configuration** with template editor, autocomplete, and entity picker! Examples:
  - RF Bridge monitoring: `{{ is_state('binary_sensor.rf_bridge_status', 'on') }}`
  - Wrapper mode: `{{ not is_state('cover.original_cover', 'unavailable') }}`
  - Complex conditions: `{{ is_state('binary_sensor.rf_bridge', 'on') and is_state('input_boolean.covers_enabled', 'on') }}`

#### TILT Configuration:
- `tilting_time_up` and `tilting_time_down` - time in seconds for the tilt to fully open/close. Can be float values (e.g., 1.5 seconds).
- `tilt_open_script_entity_id`, `tilt_close_script_entity_id`, `tilt_stop_script_entity_id` - scripts for tilt control. If not specified, the main cover scripts will be used.
- `tilt_only_when_closed` defaults to `False`. When `False` (default), tilt can be controlled independently at any time, regardless of the main cover position. This allows you to adjust lamella angle while the cover is partially or fully open, and tilt position is preserved/restored independently. Set to `True` if you want the old behavior where tilt control is only available when the main cover is fully closed (0%), and tilt is automatically reset to 0 when the cover opens.

Example with free tilt (default behavior):
```yaml
cover:
  - platform: cover_rf_time_based
    devices:
      living_room_blinds:
        name: Living Room Blinds
        travelling_time_up: 20
        travelling_time_down: 22
        tilting_time_up: 1.5
        tilting_time_down: 1.5
        open_script_entity_id: script.lr_blinds_open
        close_script_entity_id: script.lr_blinds_close
        stop_script_entity_id: script.lr_blinds_stop
        tilt_open_script_entity_id: script.lr_blinds_tilt_open
        tilt_close_script_entity_id: script.lr_blinds_tilt_close
        tilt_stop_script_entity_id: script.lr_blinds_tilt_stop
        # tilt_only_when_closed: False is the default - tilt works independently
```

Example with restricted tilt (only when closed):
```yaml
cover:
  - platform: cover_rf_time_based
    devices:
      bedroom_blinds:
        name: Bedroom Blinds
        travelling_time_up: 20
        travelling_time_down: 22
        tilting_time_up: 1.5
        tilting_time_down: 1.5
        open_script_entity_id: script.br_blinds_open
        close_script_entity_id: script.br_blinds_close
        stop_script_entity_id: script.br_blinds_stop
        tilt_open_script_entity_id: script.br_blinds_tilt_open
        tilt_close_script_entity_id: script.br_blinds_tilt_close
        tilt_only_when_closed: True  # tilt only works when cover is fully closed
```

### Example scripts.yaml entry
#### RF covers
The following example assumes that you're using an RF bridge running [Tasmota](https://tasmota.github.io/docs/devices/Sonoff-RF-Bridge-433/) or [ESPHome](#implementation-with-esphome) open source firmware to integrate your radio-controlled covers. The command scripts pass the `rfraw_data` parameter to a general transmitter script which takes care of queuing the transmission of the codes and keeping an appropriate delay between them:
```yaml
'rf_transmitter':
  alias: 'RF Transmitter'
  mode: queued
  max: 30
  sequence:
    # With Tasmota
    - service: mqtt.publish
      data:
        topic: 'cmnd/rf-bridge-1/rfraw'
        payload: '{{ rfraw_data }}'
    # With ESPHome
    - service: esphome.sonoff_rf_bridge_send_rf_raw
      data:
        raw: '{{ rfraw_data }}'
    # add a little delay
    - delay: 00:00:01

'rf_myroom_cover_down':
  alias: 'RF send MyRoom Cover DOWN'
  mode: single
  max_exceeded: silent
  sequence:
    - service: script.turn_on
      target:
        entity_id: script.rf_transmitter
      data:
        variables:
          rfraw_data: 'AAB0XXXXX....XXXXXXXXXX'

'rf_myroom_cover_stop':
  alias: 'RF send MyRoom Cover STOP'
  mode: single
  max_exceeded: silent
  sequence:
    - service: script.turn_on
      target:
        entity_id: script.rf_transmitter
      data:
        variables:
          rfraw_data: 'AAB0XXXXX....XXXXXXXXXX'

'rf_myroom_cover_up':
  alias: 'RF send MyRoom Cover UP'
  mode: single
  max_exceeded: silent
  sequence:
    - service: script.turn_on
      target:
        entity_id: script.rf_transmitter
      data:
        variables:
          rfraw_data: 'AAB0XXXXX....XXXXXXXXXX'
```

Note that for RAW data you also need the [Portisch firmware](https://github.com/Portisch/RF-Bridge-EFM8BB1/wiki) to be flashed on the EFM8BB1 embedded RF-transmitter chip of the bridge unit.
  
For the scripts above with Tasmota you need a small automation in **automations.yaml** to set `RfRaw` back to `0` to avoid spamming your MQTT server with loads of sniffed raw RF data. This trigger is checked every minute only so set `> 40` set in the `value_template` to be a bit bigger than your biggest `travelling_time`:

```yaml
- id: rf_transmitter_tasmota_cancel_sniff
  alias: 'RF Transmitter Tasmota cancel sniffing'
  trigger:
    platform: template
    value_template: "{{ ( as_timestamp(now()) - as_timestamp(state_attr('script.rf_transmitter', 'last_triggered')) | int(0) ) > 40 }}"
  action:
    - service: mqtt.publish
      data:
        topic: 'cmnd/rf-bridge-1/rfraw'
        payload: '0'
```
#### Switched covers
The example below assumes you've set `send_stop_at_ends: True` in the cover config, and you're using any [two-gang switch running Tasmota](https://tasmota.github.io/docs/devices/Sonoff-Dual-R2/) open source firmware to integrate your switch-controlled covers:
```yaml
'rf_myroom_cover_down':
  alias: 'Switches send MyRoom Cover DOWN'
  mode: single
  max_exceeded: silent
  sequence:
    - service: mqtt.publish
      data:
        topic: 'cmnd/myroomcoverswitch/POWER1' # open/close
        payload: 'OFF'
    - service: mqtt.publish
      data:
        topic: 'cmnd/myroomcoverswitch/POWER2' # power
        payload: 'ON'

'rf_myroom_cover_stop':
  alias: 'Switches send MyRoom Cover STOP'
  mode: single
  max_exceeded: silent
  sequence:
    - service: mqtt.publish
      data:
        topic: 'cmnd/myroomcoverswitch/POWER2' # power
        payload: 'OFF'
    - service: mqtt.publish
      data:
        topic: 'cmnd/myroomcoverswitch/POWER1' # open/close
        payload: 'OFF'

'rf_myroom_cover_up':
  alias: 'Switches send MyRoom Cover UP'
  mode: single
  max_exceeded: silent
  sequence:
    - service: mqtt.publish
      data:
        topic: 'cmnd/myroomcoverswitch/POWER1' # open/close
        payload: 'ON'
    - service: mqtt.publish
      data:
        topic: 'cmnd/myroomcoverswitch/POWER2' # power
        payload: 'ON'
```
Note how you don't have to configure these as switches in Home Assistant at all, it's enough just to publish MQTT commands strainght from the script (credits to [VDRainer](https://github.com/VDRainer) for this example).
Of course you can customize based on what ever other way to trigger these 3 type of movements. You could, for example, turn on and off warning lights along with the movement.

### TILT Feature Behavior

This component supports tilt control for venetian blinds, shutters, or any cover with adjustable slats/lamella. 

#### Independent TILT Control (Default):
By default (`tilt_only_when_closed: False`), the tilt position is completely independent from the main cover position:
- You can adjust tilt at any time, whether the cover is open, closed, or anywhere in between
- Opening or closing the cover does NOT reset the tilt position
- Tilt position is saved and restored after Home Assistant restarts
- This is useful for covers where slat angle can be adjusted independently, like some motorized venetian blinds

#### Restricted TILT Control:
If you set `tilt_only_when_closed: True`:
- Tilt can only be controlled when the main cover is fully closed (0%)
- Opening the cover automatically resets tilt to 0%
- Tilt commands are ignored if the cover is not fully closed
- This is useful for covers where tilt only makes sense when closed

#### TILT Scripts:
- If you provide dedicated tilt scripts (`tilt_open_script_entity_id`, etc.), they will be used for tilt operations
- If tilt scripts are not provided, the main cover scripts will be used (useful if the same motor handles both main and tilt movement)
- You can mix and match - for example, provide only `tilt_open_script_entity_id` and `tilt_close_script_entity_id`, and the main stop script will be used for tilt stop

#### Entity Attributes:
The cover entity provides these tilt-related attributes:
- `current_tilt_position` - current tilt position (0-100)
- `tilt_is_allowed` - boolean indicating if tilt control is currently available
- `tilt_only_when_closed` - shows the configured restriction mode
- `tilting_time_up` / `tilting_time_down` - configured tilt travel times

### Availability Template

The `availability_template` feature allows you to dynamically control when a cover entity is available based on other entities or conditions in your Home Assistant installation.

#### What is it?
- A Jinja2 template that returns `True` (available) or `False` (unavailable)
- When unavailable, the cover appears as "unavailable" in the UI
- Prevents sending commands when the underlying hardware is offline
- Updates automatically when monitored entities change state

#### Common Use Cases:

**1. RF Bridge Monitoring**
```yaml
availability_template: "{{ is_state('binary_sensor.rf_bridge_status', 'on') }}"
```
Cover is only available when RF Bridge is online.

**2. Wrapper Mode - Track Original Entity**
```yaml
availability_template: "{{ not is_state('cover.original_cover', 'unavailable') }}"
```
Cover wrapper is only available when the wrapped entity is available.

**3. Power Status**
```yaml
availability_template: "{{ is_state('binary_sensor.power_grid', 'on') }}"
```
Cover is unavailable during power outages.

**4. Complex Conditions**
```yaml
availability_template: >
  {{ is_state('binary_sensor.rf_bridge', 'on') and
     is_state('input_boolean.covers_enabled', 'on') and
     not is_state('alarm_control_panel.home', 'armed_away') }}
```
Multiple conditions: RF Bridge online, covers enabled, and alarm not in away mode.

**5. Time Restrictions**
```yaml
availability_template: >
  {{ is_state('binary_sensor.rf_bridge', 'on') and
     now().hour >= 6 and now().hour < 23 }}
```
Cover only available between 6 AM and 11 PM.

#### UI Configuration (New in v2.1!)
When configuring via UI, you get:
- **Template Editor**: Syntax highlighting and validation
- **Autocomplete**: Suggests entity IDs and template functions
- **Entity Picker**: Browse and select entities visually
- **Live Validation**: Immediate feedback on template errors
- **Easy Updates**: Modify template via Options flow without restart

#### Benefits:
- ‚úÖ Better user experience - users see when devices are offline
- ‚úÖ Prevents wasted commands to unavailable devices
- ‚úÖ Safer automations - conditions can check availability
- ‚úÖ Easy diagnostics - immediately see connectivity issues

### Custom Services

This component provides 3 custom services:

1.  ```cover_rf_time_based.set_known_position``` lets you specify the position of the cover (and tilt position if applicable) if you have other sources of information, i.e. sensors. It's useful as the cover may have changed position outside of HA's knowledge, and also to allow a confirmed position to make the arrow buttons display more appropriately.
1.  ```cover_rf_time_based.set_known_action``` is for instances when an action is caught in the real world but not processed in HA, e.g. an RF bridge detects a ```stop``` action that we want to input into HA without calling the stop command.
1.  ```cover_rf_time_based.send_command``` allows you to send specific cover commands programmatically, including tilt commands if supported.


#### ```cover_rf_time_based.set_known_position```

In addition to ```entity_id``` takes these optional parameters:
* ```position``` - the main cover position (0-100)
* ```tilt_position``` - the tilt position (0-100), only used if cover has tilt support
* ```confident``` that affects how the cover is presented in HA. Setting confident to ```true``` will mean that certain button operations aren't permitted.
* ```position_type``` allows the setting of either the ```target``` or ```current``` posistion.

Following examples to help explain parameters and use cases:

1.  This example automation uses ```position_type: current``` and ```confident: true``` when a reed sensor has indicated a garage door is closed when contact is made:

```yaml
- id: 'garage_closed'
  alias: 'Doors: garage set closed when contact'
  trigger:
  - entity_id: binary_sensor.door_garage_cover
    platform: state
    to: 'off'
  condition: []
  action:
  - data:
      confident: true
      entity_id: cover.garage_door
      position: 0
      position_type: current
    service: cover_rf_time_based.set_known_position
``` 

We have set ```confident``` to ```true``` as the sensor has confirmed a final position. The down arrow is now no longer available in default  HA frontend when the cover is closed. 
```position_type``` of ```current``` means the current position is moved immediately to 0 and stops there (provided cover is not moving, otherwise will contiune moving to original target). 


2.  This example uses ```position_type: target``` (the default) and ```confident: false``` (also default) where an RF bridge has interecepted an RF command, so we know an external remote has triggered cover opening action:

```yaml
- id: 'rf_cover_opening'
  alias: 'RF_Cover: set opening when rf received'
  trigger:
  - entity_id: sensor.rf_command
    platform: state
    to: 'open'
  condition: 
  - condition: state
    entity_id: cover.rf_cover
    state: closed
  action:
  - data:
      entity_id: cover.rf_cover
      position: 100
    service: cover_rf_time_based.set_known_position
```

```confident``` is omitted so defaulted to ```false``` as we're not sure where the movement may end, so all arrows are available.
```position_type``` is omitted so defaulted to ```target```, meaning cover will transition to ```position``` without triggering any start or stop actions.

3. This example sets both main position and tilt position after detecting a specific state:

```yaml
- id: 'set_cover_and_tilt_state'
  alias: 'Cover: set known position with tilt'
  trigger:
  - platform: event
    event_type: custom_cover_position_detected
  action:
  - data:
      entity_id: cover.living_room_blinds
      position: 50
      tilt_position: 75
      confident: true
    service: cover_rf_time_based.set_known_position
```

This sets both the main cover position to 50% and tilt to 75%, marking both as confident states.

#### ```cover_rf_time_based.set_known_action```
This service mimics cover movement in Home Assistant without actually sending out commands to the cover. It can be used for example when external RF remote controllers act on the cover directly, but the signals can be captured with an RF brigde and Home Assistant can play the movement in parrallel with the real cover. In addtion to ```entity_id``` takes parameter ```action``` that should be one of open, close or stop.

Example:

```yaml
- id: 'rf_cover_stop'
  alias: 'RF_Cover: set stop action from bridge trigger'
  trigger:
  - entity_id: sensor.rf_command
    platform: state
    to: 'stop'
  condition: []
  action:
  - data:
      entity_id: cover.rf_cover
      action: stop
    service: cover_rf_time_based.set_known_action
```
In this instance we have caught a stop signal from the RF bridge and want to update HA cover without triggering another stop action.

#### ```cover_rf_time_based.send_command```
This service allows you to send specific cover commands programmatically. In addition to ```entity_id```, it takes the ```command``` parameter.

Supported commands:
- ```open_cover``` - opens the main cover
- ```close_cover``` - closes the main cover
- ```stop_cover``` - stops the main cover
- ```open_cover_tilt``` - opens the tilt (if tilt support is configured)
- ```close_cover_tilt``` - closes the tilt (if tilt support is configured)
- ```stop_cover_tilt``` - stops the tilt (if tilt support is configured)

Example usage:

```yaml
- id: 'custom_tilt_open'
  alias: 'Cover: Open tilt via automation'
  trigger:
  - platform: sun
    event: sunrise
  action:
  - data:
      entity_id: cover.living_room_blinds
      command: open_cover_tilt
    service: cover_rf_time_based.send_command
```

Example with conditional command:

```yaml
- id: 'dynamic_cover_command'
  alias: 'Cover: Send dynamic command'
  trigger:
  - platform: state
    entity_id: input_select.cover_command
  action:
  - data:
      entity_id: cover.my_room_cover
      command: "{{ states('input_select.cover_command') }}"
    service: cover_rf_time_based.send_command
```

This service is particularly useful when you want to trigger specific cover actions from automations or scripts in a programmatic way.

### Icon customization
  
For proper icon display (opened/moving/closed) customization can be added with option `device_class` set either in the cover's config, based of what type of covers you have. 
  
Can also be done in `configuration.yaml`:

```yaml
homeassistant:
  customize_domain: #for all covers 
     cover:
      device_class: curtain
  customize: #for each cover separately
    cover.my_room_cover_time_based:
      device_class: curtain
```
  
More details in [Home Assistant device class docs](https://www.home-assistant.io/docs/configuration/customizing-devices/#device-class).
  

### Some tips 

#### When using this component with Tasmota RF Bridge in automations

Since there's no feedback from the cover about its current state, state is assumed based on the last command sent, and position is calculated based on the fraction of time spent travelling up or down. You need to measure time by opening/closing the cover using the original remote controller, not through the commands sent from Home Assistant (as they may introduce some delay).

Tasmota RF bridge is able to send out the radio-frequency commands very quickly. If some of your covers 'miss' the commands occassionally (you can see that from the fact that the state shown in Home Assistant does not correspond to reality), it may be that those cover motors do not understand the codes when they are sent 'at once' from Home Assistant. 

This can be handled in multiple ways:
- try increasing your RF range. Make sure the wire antennas of the covers are not tied close to the power cables or to big metallic surfaces. For 433MHz, the antenna length should be around 17cm (this may include the part going inside the tube motor). Sonoff RF Bridge has two copper helical antennas near the PCB, you can unsolder them and simply solder in place two straight hard wires of 17.3cm, which can go out through some small holes on the sides of the unit. You need to solder only one end of each wire, to the points where the helical legs were shorter (points U7 and U8). This will increase the range substantially, to the cost of aesthetics.
- avoid _backlogs_ with `rfraw AAB0XXXXX....XXXXXXXXXX; rfraw 0` if you need multiple covers opening and closing at once. Switching the sniff on and off quickly for every cover movement may cause issues. It's enough to send `rfraw 0` only once with some delay after all procedures related to cover movements finished, the example scripts above take care of that.
- if you are sending `0xB0` codes (decoded with [BitBucketConverter.py](https://github.com/Portisch/RF-Bridge-EFM8BB1)) you can tweak those to be sent with repetitions (multiple times) by changing the repetition parameter (5th byte) of the code. [For example](https://github.com/arendst/Tasmota/issues/5936#issuecomment-500236581) 20 repetitions can be achieved by changing 5th byte from 04 to 14. Also BitBucketConverter can be run by specifiying the required repetitions at command line before decoding. Some covers might not like this, though.
- alternatively, you can further reduce stress by making sure you don't use [cover groups](https://www.home-assistant.io/integrations/cover.group/) containing multiple covers provided by this integration, and also in automation don't include multipe covers separated by commas in one service call. You could create separate service calls for each cover, moreover, add more delay between them:
```yaml
- alias: 'Covers down when getting dark'
  mode: single
  max_exceeded: silent
  trigger:
    - platform: numeric_state
      below: 400
      for: "00:05:00"
      entity_id: sensor.outside_light_sensor
  action:
    - service: cover.close_cover
      entity_id: cover.room_1
    - delay: '00:{{ (range(1,10)|random|int) }}:00'
    - service: cover.close_cover
      entity_id: cover.room_2
    - delay: '00:00:02'
    - service: cover.set_cover_position
      data:
        entity_id: cover.room_3
        position: 20
    - delay: '00:00:01'
    - service: cover.set_cover_position
      data:
        entity_id: cover.room_4
        position: 30
```

#### Implementation with ESPHome

Use the following configuration for [ESPHome on Sonoff RF Bridge](https://esphome.io/components/rf_bridge.html):
  
```yaml
substitutions:
  device_name: sonoff-rf-bridge
  friendly_name: "RF Bridge"
  device_ip: 192.168.81.22

esphome:
  name: ${device_name}
  platform: ESP8266
  board: esp01_1m
  esp8266_restore_from_flash: true

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  manual_ip:
    static_ip: ${device_ip}
    gateway: 192.168.81.254
    subnet: 255.255.255.0
  use_address: ${device_ip}

logger:
  baud_rate: 0
  level: INFO

uart:
  tx_pin: GPIO01
  rx_pin: GPIO03
  baud_rate: 19200

rf_bridge:

api:
  reboot_timeout: 15min
  password: !secret api_password
  encryption:
    key: !secret encryption_key
  services:
    - service: send_rf_raw
      variables:
        raw: string
      then:
        - rf_bridge.send_raw:
            raw: !lambda 'return raw;'

ota:
  password: !secret ota_password

web_server:
  version: 2
  local: true
  port: 80

```

